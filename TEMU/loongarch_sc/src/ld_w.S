#include "regdef.h"
#include "trap.h"

    .section .text
    .globl  _start

_start:
    lu12i.w $r10, 0x10000      # r10 = 0x10000000（基地址）
    
    # 测试用例1：存储并加载字
    # 预期：加载应返回存储的内容
    lu12i.w $r12, 0x12345      # r12 = 0x12345000
    ori     $r12, $r12, 0x678  # r12 = 0x12345678
    st.w    $r12, $r10, 0      # mem[0x80010000] = 0x12345678
    ld.w    $r13, $r10, 0      # r13 = mem[0x80010000]
    
    # 测试用例2：用正偏移存储和加载
    # 预期：从偏移4加载
    lu12i.w $r14, -344098     # r14 = 0xABCDE000
    ori     $r14, $r14, 0xF01  # r14 = 0xABCDEF01
    st.w    $r14, $r10, 4      # mem[0x80010004] = 0xABCDEF01
    ld.w    $r15, $r10, 4      # r15 = mem[0x80010004]
    
    # 测试用例3：存储和加载零
    # 预期：加载零
    st.w    $r0, $r10, 8       # mem[0x80010008] = 0
    ld.w    $r16, $r10, 8      # r16 = mem[0x80010008] = 0
    
    # 测试用例4：存储和加载负数
    # 预期：加载0xFFFFFFFF
    lu12i.w $r17, -1           # r17 = 0xFFFFF000
    ori     $r17, $r17, 0xFFF  # r17 = 0xFFFFFFFF
    st.w    $r17, $r10, 12     # mem[0x8001000C] = 0xFFFFFFFF
    ld.w    $r18, $r10, 12     # r18 = mem[0x8001000C]
    
    # 测试用例5：从多个地址加载
    # 在不同偏移存储不同值
    lu12i.w $r19, 0x00000      # r19 = 0
    ori     $r19, $r19, 0x111  # r19 = 0x111
    st.w    $r19, $r10, 16     # mem[0x80010010] = 0x111
    
    lu12i.w $r20, 0x00000      # r20 = 0
    ori     $r20, $r20, 0x222  # r20 = 0x222
    st.w    $r20, $r10, 20     # mem[0x80010014] = 0x222
    
    # 加载回来
    ld.w    $r21, $r10, 16     # r21 = mem[0x80010010] = 0x111
    ld.w    $r22, $r10, 20     # r22 = mem[0x80010014] = 0x222
    
    # 测试用例6：用负偏移加载
    # 使用地址0x80010020，偏移-4从0x8001001C读取
    lu12i.w $r23, -489336     # r23 = 0x88888000
    ori     $r23, $r23, 0x888  # r23 = 0x88888888
    st.w    $r23, $r10, 28     # mem[0x8001001C] = 0x88888888
    
    addi.w  $r24, $r10, 32     # r24 = 0x80010020
    ld.w    $r25, $r24, -4     # r25 = mem[0x8001001C] = 0x88888888
    
    # 所有测试通过
    HIT_GOOD_TRAP